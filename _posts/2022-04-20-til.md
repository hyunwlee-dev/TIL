---
layout: post
title: "Algorithm"
author: "hyunwlee"
---

# <span style='background:hotpink; color:white'>BOJ 1107 리모컨</span>

```
let min = Number.MAX_SAFE_INTEGER;
let arr = null;
let check = null;
let n = null;

function solution() {
    n = input[0];
    const m = +input[1];
    check = Array.from({length: 10}, item => false);
    if (m !== 0)
    {
        arr = input[2].split(' ').map(item => +item).sort((a, b) => (b - a));
        for (let n of arr)
            check[n] = true;
    }
    arr = Array.from({length: 6}, item => 0);
    if (parseInt(n) === 100)
    {
        console.log(0);
        return ;
    }

    min = Math.min(min, Math.abs(100 - parseInt(n)));
    DFS(0, '');
    console.log(min);
}

function DFS(depth, s) {
    if (depth === 6)
        return;
    for (let i = 0; i <= 9; ++i)
    {
        if (check[i])
            continue;
        let newS = s + i;
        let sum = parseInt(newS);
        min = Math.min(min, (Math.abs(sum - parseInt(n)) + (depth + 1)));
        DFS(depth + 1, newS);
    }
}
```

효율적으로 풀기위해 처음에는 한자리 수 마다 가능한 숫자를 최대치로 하여 풀려했으나  

```
500000
8
0 2 3 4 6 7 8 9
```

테스트케이스가 이럴 경우  

첫자리 5!  

다음자리 !?  5로 시작해서는 다음자리가 올 수 있는 경우가 없다.  

  

##### 따라서 다른 풀이법을 찾아야 했고, BruteForce를 이용하여 풀어도 충분했다.  

처음에 효율성을 위해 bruteforce를 사용하지 않으려고 했지만 O(999,999)는 1초에 1억번 연산하는 컴퓨터에게 별거 아닌 수치이다.  

# BOJ 1260 DFS와 BFS

```
let list = null;
let check = null;
function solution()
{
    const [n, m, v] = input.shift().split(' ').map(item => +item);
    // List<Integer>[] list = new ArrayList[n];
    list = Array.from(Array(n + 1), () => Array());
    for (let i = 0; i < m; ++i)
    {
        const [from, to] = input[i].split(' ');
        list[from].push(to);
        list[to].push(from);
    }
    for (let i = 0; i <= n; ++i)
        list[i].sort((a, b) => (a - b));
    check = Array.from({length: n + 1}, item => false);
    DFS(v);
    check = Array.from({length: n + 1}, item => false);
    console.log();
    BFS(v);
}

class Node {
    constructor(item) {
        this.value = item;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    offer(item) {
        const newNode = new Node(item);
        if (!this.head)
        {
            this.head = newNode;
            this.tail = newNode;
        }
        else
        {
            this.tail.next = newNode;
            this.tail = newNode;
        }
        ++this.size;
    }
    poll()
    {
        const ret = this.head.value;
        this.head = this.head.next;
        if (!this.head)
            this.tail = null;
        --this.size;
        return (ret);
    }
    peek()
    {
        return (this.head.value);
    }
    isEmpty()
    {
        return (this.head === null);
    }
}

function BFS(x)
{
    const queue = new LinkedList();
    queue.offer(x);
    check[x] = true;
    process.stdout.write(x + ' ');
    while (!queue.isEmpty())
    {
        const temp = queue.poll();
        for (let n of list[temp])
        {
            if (check[n])
                continue;
            check[n] = true;
            process.stdout.write(n + ' ');
            queue.offer(n);
        }
    }
}

function DFS(x)
{
    if (check[x])
        return ;
    check[x] = true;
    process.stdout.write(x + ' ');
    for (let n of list[x])
    {
        if (check[n])
            continue;
        DFS(n);
    }
}
```

# BOJ 1389 케빈 베이컨의 6단계 법칙

```
let list = null;
let dist = null;
function solution() {
    const [n, m] = input.shift().split(' ').map(item => +item);
    list = Array.from(Array(n + 1), () => Array().fill(null));
    for (let i = 0; i < m; ++i)
    {
        const [from, to] = input[i].split(' ').map(item => +item);
        list[from].push(to);
        list[to].push(from);
    }
    for (let i = 1; i <= n; ++i)
        list[i].sort((a, b) => (a - b));
    let answer = 0;
    let min = Number.MAX_SAFE_INTEGER;
    for (let who = n; who >= 1; --who)
    {
        dist = Array.from({length: n + 1}, item => -1);
        BFS(who);
        const sum = dist.reduce((cal, cur) => (cal += cur), 1);
        if (min >= sum)
        {
            min = sum;
            answer = who;
        }
    }
    console.log(answer);
}

class Node {
    constructor(item) {
        this.value = item;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    offer(item) {
        const newNode = new Node(item);
        if (!this.head)
        {
            this.head = newNode;
            this.tail = newNode;
        }
        else
        {
            this.tail.next = newNode;
            this.tail = newNode;
        }
        ++this.size;
    }
    poll() {
        const ret = this.head.value;
        this.head = this.head.next;
        if (!this.head)
            this.tail = null;
        --this.size;
        return (ret);
    }
    peek() {
        return (this.head.value);
    }
    isEmpty() {
        return (this.head === null);
    }
}

function BFS(who) {
    const queue = new LinkedList();
    queue.offer(who);
    dist[who] = 0;
    while (!queue.isEmpty())
    {
        const temp = queue.poll();
        for (let person of list[temp])
        {
            if (dist[person] !== -1)
                continue;
            dist[person] = dist[temp] + 1;
            queue.offer(person);
        }
    }
}

/* 멍청아 BFS로 풀었어야지. 다음엔 생각하고 푸시길 */
// function DFS(depth, who, findingYou)
// {
//     if (check[who])
//         return ;
//     check[who] = true;
//     if (who === findingYou)
//     {
//         cnt = depth;
//         return;
//     }
//     for (let p of list[who])
//         DFS(depth + 1, p, findingYou);
// }
```









# React input type='file' 미리보기

```
const [academyInfo, setAcademyInfo] = useState({
	...: '',
	...: '',
	...: '',
	representImgFile: '',
});
/* 이미지가 보여질 구간 */
<div>
	{academyInfo.representImgFile}
</div>
/* 찾아보기 버튼역할 라벨 */
<label htmlFor='representImgFile'>
	찾아보기
</label>
/* 이미지를 받기위해서 사용되어야만하는 input, 숨겨짐 */
<input
	type='file'
	id='representImgFile'
	// ref={hiddenRepresentImgFileInputRef}
	onChange={handleChangeRepresentImg}
	style={{display: 'none'}}  /* 파일 입력 요소를 보이지 않게 만듭니다. */
/>
```

이미지를 미리보기 위해서는

```
<img src=''/>
```

안에 들어갈 2가지 값이 필요하다.

- <span style="color:red"><strong>base64 인코딩</strong></span>
- <span style="color:red"><strong>file의 상태</strong></span>

```
/* 추가할 항목 */
// 1. base64 인코딩
const[imgBase64, setImgBase64] = useState('');
// 2. file의 상태값
const[imgFile, setImgFile] = useState(null);
```

다음은 input file의 태그가 동작될 때마다 수행할 <strong>onChange</strong> 이벤트 핸들러를 작성하도록 한다.

```
const handleClickFile = (e) => {
	const reader = new FileReader();
	
	/* 읽기가 완료되었다면 */
	reader.onloadend = () => {
			const base64 = reader.result;
			// 파일의 내용을 반환함. 이 속성은 읽기가 완료 된 후에만 사용가능함.
			// 데이터의 형식은 읽기 작업에 어떤 함수가 사용되었는가에 의해 정해짐. => 
			if (base64)
	}
}
```









# event.preventDefault

form submit이나 a href의 동작을 막아 줄 수 있다.  

form안에 submit 역할을 



# 권한 주기

#### 사용자 관리 6개

- [ ] 사용자 정보
- [ ] 탈퇴 사용자 정보
- [ ] 리뷰 관리
- [ ] 착캐쉬 및 포인트 관리
- [ ] AI 자가진단 보고서

#### 학원 관리 6개

- [ ] 학원 정보
- [ ] 포인트 관리
- [ ] 광고 현황
- [ ] 문의 현황
- [ ] 탈퇴 학원 정보
- [ ] 리뷰 관리

#### 콘텐츠 관리 6개

- [ ] 오늘의 착한퀴즈 관리
- [ ] 테마 문제 관리
- [ ] 자기진단 테스트 관리
- [ ] 비법 창고
- [ ] 입시 창고
- [ ] 운영 창고

#### 이벤트 관리 5개

- [ ] 포인트/캐쉬 배수이벤트 관리
- [ ] 룰렛 이벤트 관리
- [ ] 기타 이벤트 관리
- [ ] 학원 광고 관리
- [ ] 앱내 광고 관리

#### 기타 관리 3게

- [ ] 공지 사항
- [ ] 계정 관리
- [ ] 키원드 관리





# 안된것 

1. 기타관리
   - 계정 관리
     - newRegistrationAccount - rw
     - detailAccountInfo - r
     - changeAccount - rw
   - 쿠폰 등록
2. checkValidation
3. 이미지 보이게
4. 학원소개 react-quill
5. 문의 현황 texture 글자 간격
6. 총판 번호 없애기?



# 운영하는 것들

1. 사용자 관리
   - 사용자 정보 => select 빼라 ✅
   - 탈퇴 사용자 정보 ✅
   - 리뷰 관리 ✅
2. 학원 관리
   - 학원 정보 => 총판 번호 넣기 ✅
   - 광고 현황 => <strong>set.</strong> 이벤트 관리 - 광고 관리 - 학원 광고 관리 ✅
   - 문의 사항 ✅
   - 리뷰 관리 => 삭제로 이동x ✅
3. 기타 관리
   - 공지 사항 => 신규 등록(불필요한 select 삭제) ✅
   - <mark><span style='color:red'>계정 관리 - 자세히 - 신규등록 & 자세히(update) - <strong>checkbox넣기</strong></span></mark>
   - <mark><span style='color:red'>쿠폰 등록 {구분(combobox), 제목(text), 이미지(file), 시작기간~끝기간}</span></mark>

# FIX

#### total

- 탈퇴: alert 띄우기 (사용자 관리✅, )
- 가입, 수정: 이메일, 전화번호 유효성 검사하기 📌 
  - changeDetailAcademyInfo
  - newRegistrationAccount
  - changeAccount
- table: react-table => 기본 테이블 ✅

```
 js checkValidation
1. 이메일
2. 전화번호
```



#### sideBar

- 들여쓰기 ✅
- div로 선택되게 ✅
- 새로고침 focus 풀리지 않게 ✅

### input type='file' 이미지 보이게끔

<mark>학원관리 광고  이벤트관리 광고관리 학원광고</mark> ✅

<mark>이미지 보이게</mark> 

<mark>총판번호 없애기</mark> 

<mark>학원소개 react-quill 사용</mark> 

문의현황 - texture 글자간격

학원관리 셀렉트 ✅

학원관리 플레이스 홀더 ✅

공지사항 말머리 ✅

서비스 관리 => 키워드 관리 ✅

운영 안하는 것들: alert(작업중인 페이지입니다.) ✅

로고 비즈니스앱 지우기 ✅

서체 지우기x ✅

키워드 버튼 저장x ✅

학원 관리 - 학원 정보 - 자세히 - 수정 - 멤버십 여부: 일단 냅두기 ⚠️



# 문제 삼을 만한 것

1. 학생 or 부모에 따라 달라지는 component
2. 막연히 놓은 더미값들.. 데이터가 어떻게 들어올려나..
3. <ins>props는 단방향기 때문에 popup같은 기능들이 너무 비효율 적인 것 (=== <strong>Props Drillig</strong>)</ins>
   - sol1) useContext?
   - sol2) redux?

1번, 2번 같은 걱정은 API를 다루면서 호기심이 해결될 것 같음.





# React-table



### 사용한 이유:

1. pagination, globalfilter등 다양한 기술을 제공한다. 어렵지 않다.
2. 재사용성에 유리하다.

총 페이지

그룹 몇개로?

현재 페이지


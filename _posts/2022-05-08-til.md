---
layout: post
title: "CSS variables & Using data attributes & BEM, BOJ Dual PriorityQueue & BFS, React"
author: "hyunwlee"
---

# Custom properties (--*): CSS variables

[CSS variables](https://developer.mozilla.org/en-US/docs/Web/CSS/--*)

```
:root {
	--font-size: 32px;
	--background-color: thistle;
	--text-color: whitesmoke;
	--base-space: 8px;
}

.first-list {
	background-color: var(--background-color);
	color: var(--text-color);
	margin-left: var(--base-space);
}

.second-list {
	background-color: var(--background-color);
	color: var(--text-color);
	margin-left: calc(var(--base-space) * 2);
}

/* âœ¨ë¯¸ë””ì–´ ì¿¼ë¦¬ì—ì„œ ë¹›ì„ ë°œíœ˜í•¨ */
@media screen and (max-width: 768px) {
	:root {
		--background-color: salmon;
		--text-color: blue;
		--base-space: 4px;
	}
}
```



# Using data attributes

html ì†ì„±ìš”ì†Œë¥¼ ì¶”ê°€í•´ì¤€ë‹¤. ì›í•˜ëŠ” ë°ì´í„°ë¥¼ DOMìš”ì†Œì— ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.  

but, ë³´ì•ˆì— ì·¨ì•½  

```
<div id='' class=''></div>

=>
<style>
	div[data-display-name='hyunwlee'] {
		background-color: beige;
	}
</style>


<div data-index='1' data-display-name='hyunwlee'></div>
<div data-index='2' data-display-name='hello'></div>
<span data-index='1' data-display-name='hyunwlee'></span>

/* íŠ¹ì´ì : ì´ë ‡ê²Œ DOMìš”ì†Œì— ì ‘ê·¼ ê°€ëŠ¥*/
<script>
	console.log(hyunwlee.dataset.displyName);
</script>
```



# BEM

<strong>CSSë¥¼ íš¨ìœ¨ì ì´ê³  ë¹ ë¥´ê²Œ ì‘ì„±í•˜ê¸° ìœ„í•œ ì›¹ ê°œë°œ ë°©ë²•ë¡ </strong>  

ë³´í†µ ì‘ì€ ì›¹í˜ì´ì§€ë¥¼ êµ¬ì„±í•  ë•Œì— CSS, SASSì™€ ê°™ì€ ë°©ì‹ì„ ì‚¬ìš©í•´ì„œ ì‹œì‘í•˜ê²Œ ëœë‹¤.  

ì›¹ í˜ì´ì§€ê°€ ì»¤ì§„ë‹¤ë©´, í•˜ë‚˜ì˜ CSSíŒŒì¼ë¡œëŠ” ì„ì˜ë¡œ ì‘ì„±í•œ ì†ŒìŠ¤ì½”ë“œê°€ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê¸° í˜ë“¤ê²Œ ë˜ì–´ ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë µê²Œ ë  ê²ƒì´ë‹¤.  

  

ì‹¤ë¬´ì—ì„œ ê·œëª¨ê°€ ìˆëŠ” í”„ë¡œì íŠ¸ ê²½ìš°ì—” PostCSSì™€ ê°™ì´ CSS ëª¨ë“ˆì„ ì´ìš©í•´ì„œ ë³„ë„ì˜ BEMì„ ì“°ì§€ ì•Šì•„ë„ ê°„í¸í•˜ê²Œ ì´ë¦„ì„ ì§€ì„ ìˆ˜ ìˆë‹¤.  

BEMì€ ë”± ì •í•´ì§„ ì •ë‹µì´ ìˆëŠ”ê²Œ ì•„ë‹ˆë¼ì„œ ìš°ë¦¬ê°€ ê·œì •í•˜ê³  ìƒê°í•˜ê¸° ë‚˜ë¦„ì¸ê²ƒ ê°™ë‹¤.  

  

### ì´ì 

1. ì½”ë“œ ì‘ì„± ì‹œê°„ì´ ì¤„ì–´ë“ ë‹¤: ëª¨ë“ˆí™” ë˜ì–´ í•œ ë²ˆ ì˜ ì‘ì„±í•´ë†“ìœ¼ë©´ ì‘ì„±í•œ ì½”ë“œë¥¼ ë¶ˆëŸ¬ì˜¤ë©´ ëœë‹¤.
2. ì‘ì„±í•´ì•¼ í•˜ëŠ” ì½”ë“œì–‘ì´ ì¤„ì–´ë“ ë‹¤: ì¤‘ì²©í•´ì„œ CSSì½”ë“œë¥¼ ì‘ì„±í•  í•„ìš”ê°€ ì—†ê¸° ë•Œë¬¸ì— ì‘ì„±í•  ì†ŒìŠ¤ì½”ë“œ ì–‘ì´ ì¤„ì–´ë“ ë‹¤.
3. ë¸Œë¼ìš°ì € ë¡œë”© ì†ë„ ì´ì : í•œ íƒœê·¸ì— ëŒ€í•´ì„œ ì—¬ëŸ¬ ì„ íƒìë¥¼ ë¶ˆëŸ¬ì˜¬ í•„ìš”ê°€ ì—†ë‹¤.



#### ë‹¤ë¥¸ ë°©ë²•ë¡ ë„ ìˆëŠ”ë° ì™œ BEMì„ ì‚¬ìš©í•˜ë‚˜

êµ¬ì¡°í™”ëœ CSSë¡œ ì¸í•´ í˜¼ë€ì´ ì ìœ¼ë©° ì¢‹ì€ ì•„í‚¤í…ì²˜ë¥¼ êµ¬ì„±í•˜ì—¬ ì‰½ê²Œ ì¸ì‹í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì‚¬ìš©í•´ì•¼ í•œë‹¤.  

  

#### BEMì˜ 3ê°€ì§€ êµ¬ì„±ìš”ì†Œ

BEMë°©ë²•ë¡ ì€ HTML, CSS êµ¬ì„±ìš”ì†Œ ì¤‘ classë§Œ ê´€ë ¨ë˜ì–´ ìˆë‹¤.  

1. Block: ë…ë¦½ì ìœ¼ë¡œ ì¡´ì¬í•˜ëŠ” êµ¬ì„±ìš”ì†Œ

   ex) header, container, menu, checkbox, input

2. Element: ë¸”ë¡ì˜ ë¶€ë¶„ì´ë©° ì˜ë¯¸ì ìœ¼ë¡œ ë¸”ë¡ì—¥ ì¢…ì†ë¨

   ex) header title, menu item, checkbox caption, list item

3. Modifier: ë¸”ë¡, ì—˜ë¦¬ë¨¼íŠ¸ì˜ í”Œë˜ê·¸ì´ë©° ì™¸í˜•ì´ë‚˜ í–‰ë™ì„ ë°”ê¿ˆ

   ex) disabled, highlighted, checked, fixed, size small, color green

#### Block - Element - Modifier  

`block__element--modifier`



#### Example1

```
.card
.card__img
.card__title
.card__description
// .card__button
.button
```

```
.card--dark
.card__img
.card__title
.card__description
// .card__button--blue
.button--blue
```

ë²„íŠ¼ì´ ë§Œì•½ ì¹´ë“œ ì•ˆì—ì„œ ë¿ë§Œì•„ë‹ˆë¼ ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ì—ë„ ê³µí†µì ìœ¼ë¡œ ì“°ì¸ë‹¤ë©´ ì¹´ë“œ ì•ˆì— ì†í•  í•„ìš”ê°€ ì—†ë‹¤.  

ë²„íŠ¼ ìì²´ë¡œ ì»´í¬ë„ŒíŠ¸ë¡œ ì‘ì„±í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.  

#### Example2

```
<section>
	<button class="button">Normal button</button>
	<button class="button button__state--success">Success button</button>
	<button class="button button__state--danger">Danger button</button>
	<button class="button button__state--disabled">Disabled button</button>
</section>
```

- block: button
- element: state--success, state--danger
- modifier: disabled

```
.button {
	display: inline-block;
	border-radius: 3px;
	padding: 7px 12px;
	border: 1px solid #F0F0F0;
	background-image: linear-gradient(#EEE, #DDD);
	font: 700 13px/18px Helvetica, arial;
}

.button--state-success { 
	color: #FFF; 
	background: #569E3D 
	linear-gradient(#79D858, #569E3D) repeat-x; 
	border-color: #4A993E; 
} 

.button--state-danger {
	color: #900; 
} 

.button--state-disabled { 
	color: white; 
	background-image: linear-gradient(#bebebe, #f2f2f2);
}
```

#### Example3

```
<div class="block"> 
	<span class="block__span">default</span> 
	<span class="block__span block__span--first span--size-big">first</span>
	<span class="block__span block__span--second">second</span> 
</div>
```

```
.block {
	margin-top: 50px;
	color: #042;
}

.block__span {
	border-radius: 10px;
	background-color: lightgray;
	padding: 8px;
}

.block__span--first {
	color: red;
}

.block__span--second {
	color: #009;
}
```

### Example4

```
<form class="form form--theme-xmax from--simple">
	<input class="form__input" type="text"/>
	<input class="form__submit" type="submit"/>
	<input class="form__submit form__submit--disabled" type="submit"/>
</form>
```

```
.span--size-big {
	font-size: 24px;
} 
.form {
	margin-top: 50px;
	font-size: 16px;
}
.form--theme-xmax {
	color: red;
}
.form--simple {
	font-weight: normal;
}
.form__input {
	padding: 8px;
	border-radius: 10px;
	outline: none;
}
.form__submit {
	font-weight: bold;
	outline: none;
	padding: 8px;
	border-radius: 10px;
	background-image: linear-gradient(#EEE, #DDD);
}
.form__submit--disabled {
	color: white;
	background-image: linear-gradient(#bebebe, #f2f2f2);
}
```



# <span style="background:hotpink">BOJ 7662 ì´ì¤‘ ìš°ì„ ìˆœìœ„ í</span>

```
class MinHeap {
    constructor() {
        this.heap = [];
    }
    getLeftChildIdx(parentIdx) {
        return (2 * parentIdx + 1);
    }
    getRightChildIdx(parentIdx) {
        return (2 * parentIdx + 2);
    }
    getParentIdx(childIdx) {
        return (Math.floor((childIdx - 1) / 2));
    }

    insert(item) {
        this.heap.push(item);
        if (this.heap.length > 0)
            this.heapifyUp();
    }

    heapifyUp() {
        let idx = this.heap.length - 1;
        // const lastItem = this.heap[this.heap.length - 1];
        while (idx > 0)
        {
            const parentIdx = this.getParentIdx(idx);
            if (this.heap[parentIdx] > this.heap[idx])
            {
                const temp = this.heap[parentIdx];
                this.heap[parentIdx] = this.heap[idx];
                this.heap[idx] = temp;
                idx = parentIdx;
            }
            else
                break;
        }
    }

    top() {
        if (this.heap.length === 0)
            return (undefined);
        else
            return (this.heap[0]);
    }

    delete() {
        const ret = this.heap[0];
        if (this.heap.length === 0)
            return (undefined);
        else if (this.heap.length === 1)
            this.heap = [];
        else
        {
            this.heap[0] = this.heap.pop();
            this.heapifyDown();
        }
        return (ret);
    }

    heapifyDown() {
        let idx = 0;
        while (this.getLeftChildIdx(idx) < this.heap.length)
        {
            const leftChildIdx = this.getLeftChildIdx(idx);
            const rightChildIdx = this.getRightChildIdx(idx);
            const smallerChildIdx =
                    (rightChildIdx < this.heap.length
                        && this.heap[rightChildIdx] < this.heap[leftChildIdx])
                    ?
                    rightChildIdx
                    :
                    leftChildIdx;
            if (this.heap[smallerChildIdx] < this.heap[idx])
            {
                const temp = this.heap[smallerChildIdx];
                this.heap[smallerChildIdx] = this.heap[idx];
                this.heap[idx] = temp;
                idx = smallerChildIdx;
            }
            else
                break;
        }
    }
}

class MaxHeap {
    constructor() {
        this.heap = [];
    }
    getLeftChildIdx(parentIdx) {
        return (2 * parentIdx + 1);
    }
    getRightChildIdx(parentIdx) {
        return (2 * parentIdx + 2);
    }
    getParentIdx(childIdx) {
        return (Math.floor((childIdx - 1) / 2));
    }
    insert(item) {
        this.heap.push(item);
        if (this.heap.length > 0)
            this.heapifyUp();
    }
    heapifyUp() {
        let idx = this.heap.length - 1;
        while (idx > 0)
        {
            const parentIdx = this.getParentIdx(idx);
            if (this.heap[parentIdx] < this.heap[idx])
            {
                const temp = this.heap[parentIdx];
                this.heap[parentIdx] = this.heap[idx];
                this.heap[idx] = temp;
                idx = parentIdx;
            }
            else
                break;
        }
    }

    top() {
        if (this.heap.length === 0)
            return (undefined);
        else
            return (this.heap[0]);
    }

    delete() {
        const ret = this.heap[0];
        if (this.heap.length === 0)
            return (undefined);
        else if (this.heap.length === 1)
            this.heap = [];
        else
        {
            this.heap[0] = this.heap.pop();
            this.heapifyDown();
        }
        return (ret);
    }

    heapifyDown() {
        let idx = 0;
        while (this.getLeftChildIdx(idx) < this.heap.length)
        {
            const leftChildIdx = this.getLeftChildIdx(idx);
            const rightChildIdx = this.getRightChildIdx(idx);
            const biggerIdx =
                (rightChildIdx < this.heap.length
                    && this.heap[rightChildIdx] > this.heap[leftChildIdx])
                    ?
                    rightChildIdx
                    :
                    leftChildIdx;
            if (this.heap[biggerIdx] > this.heap[idx])
            {
                const temp = this.heap[biggerIdx];
                this.heap[biggerIdx] = this.heap[idx];
                this.heap[idx] = temp;
                idx = biggerIdx;
            }
            else
                break;
        }
    }
}

class MinPriorityQueue extends MinHeap{
    constructor() {
        super();
    }
    offer(item) {
        this.insert(item);
    }
    poll() {
        return (this.delete());
    }
    peek() {
        return (this.top());
    }
    isEmpty() {
        return (this.heap.length === 0);
    }
}

class MaxPriorityQueue extends MaxHeap{
    constructor() {
        super();
    }
    offer(item) {
        this.insert(item);
    }
    poll() {
        return (this.delete());
    }
    peek() {
        return (this.top());
    }
    isEmpty() {
        return (this.heap.length === 0);
    }
}

function solution() {
    const t = +input.shift();
    let sum = 0;
    let ans = '';
    for (let i = 0; i < t; ++i)
    {
        const minPriorityQueue = new MinPriorityQueue();
        const maxPriorityQueue = new MaxPriorityQueue();
        // const set = new Set();
        const map = new Map();
        const n = +input[sum];
        for (let j = sum + 1; j <= sum + n; ++j)
        {
            const arr = input[j].split(' ');
            if (arr[0] === 'I')
            {
                minPriorityQueue.offer(parseInt(arr[1]));
                maxPriorityQueue.offer(parseInt(arr[1]));
                if (map.get(+arr[1]) > 0)
                {
                    let val = map.get(+arr[1]);
                    map.set(+arr[1], val + 1);
                }
                else
                    map.set(+arr[1], 1);
            }
            else if (arr[0] === 'D')
            {
                if (arr[1] === '1') // max delete
                {
                    while (map.get(maxPriorityQueue.peek()) === 0)
                        maxPriorityQueue.poll();
                    if (!maxPriorityQueue.isEmpty() && map.get(maxPriorityQueue.peek()) > 0)
                    {
                        let val = map.get(maxPriorityQueue.peek());
                        map.set(maxPriorityQueue.poll(), val - 1);
                    }
                }
                else    // min delete1
                {
                    while (map.get(minPriorityQueue.peek()) === 0)
                        minPriorityQueue.poll();
                    // if (!minPriorityQueue.isEmpty())
                    //     map.set(minPriorityQueue.poll(), 0);
                    if (!minPriorityQueue.isEmpty() && map.get(minPriorityQueue.peek()) > 0)
                    {
                        let val = map.get(minPriorityQueue.peek());
                        map.set(minPriorityQueue.poll(), val - 1);
                    }
                }
            }
        }
        sum += n + 1;
        let max = Number.MIN_SAFE_INTEGER;
        let min = Number.MAX_SAFE_INTEGER;
        let isEmpty = true;
        for (const[key, value] of map.entries())
        {
            if (value > 0)
                isEmpty = false;
            if (value >= 1)
            {
                max = Math.max(max, key);
                min = Math.min(min, key);
            }
        }
        if (isEmpty || (minPriorityQueue.heap.length < 1 || maxPriorityQueue.heap.length < 1))
            ans += 'EMPTY\n';
        else
            ans += (max + " " + min +'\n');
    }
    console.log(ans);
}
```

# <span style='background:hotpink'>BOJ 9019 DSLR</span>

```
class Node {
    constructor(item) {
        this.value = item;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    offer(item) {
        const newNode = new Node(item);
        if (!this.head)
        {
            this.head = newNode;
            this.tail = newNode;
        }
        else
        {
            this.tail.next = newNode;
            this.tail = newNode;
        }
        ++this.size;
    }
    poll() {
        const ret = this.head.value
        this.head = this.head.next;
        if (!this.head)
            this.tail = null;
        --this.size;
        return (ret);
    }
    isEmpty() {
        return (this.head === null)
    }
}

function solution() {
    const t = +input[0];
    let s = '';
    for (let idx = 0; idx < t; ++idx)
    {
        const[n, target] = input[idx + 1].split(' ').map(item=>parseInt(item));
        const dist = Array.from({length: 10001}, item=>'');
        /* ë¬¸ìì—´ .. */
        const from = Array.from({length: 10001}, item=>0);
        s += retryBFS(n, target, dist, from) + '\n';
    }
    console.log(s);
}

function retryBFS(n, target, dist, from) {
    const queue = new LinkedList();
    queue.offer(n);
    dist[n] = '';
    let ret = '';
    while (!queue.isEmpty())
    {
        const now = queue.poll();

        if (now === target)
        {
            let to = target;
            while (to !== n)
            {
                ret += dist[to];
                to = from[to];
            }
            return (ret.split("").reverse().join(""));
        }

        let next = (now * 2) % 10000;
        if (dist[next] === '')
        {
            queue.offer(next);
            from[next] = now;
            dist[next] = 'D';
        }

        next = (now === 0) ? 9999 : now - 1;
        if (dist[next] === '')
        {
            queue.offer(next);
            from[next] = now;
            dist[next] = 'S';
        }

        /* dequeë¡œ ì‚½ì…, ì‚­ì œ O(n)
         * âœ¨ ë°”ë¡œ ê³„ì‚° O(1)
         */
        next = (now % 1000) * 10 + Math.floor(now / 1000);
        if (dist[next] === '')
        {
            queue.offer(next);
            from[next] = now;
            dist[next] = 'L';
        }

        next = Math.floor(now / 10) + (now % 10) * 1000;
        if (dist[next] === '')
        {
            queue.offer(next);
            from[next] = now;
            dist[next] = 'R';
        }
    }
}

/* FAIL ğŸ’¥TIME EXCEEDEDğŸ’¥ */
function BFS(n, target, dist) {
    const queue = new LinkedList();
    queue.offer(n);
    dist[n] = '';
    while (!queue.isEmpty())
    {
        const now = queue.poll();
        if (now === target)
        {
            return (dist[now]);
        }
        /* D */
        let dResult = now * 2;
        if (dResult > 9999)
            dResult %= 10000;
        if (dist[dResult] === '')
        {
            queue.offer(dResult);
            dist[dResult] += dist[now] + 'D';
        }
        /* R */
        const sResult = (now === 0) ? 9999 : now - 1;
        if (dist[sResult] === '')
        {
            queue.offer(sResult);
            dist[sResult] += dist[now] + 'R';
        }
        const charArray = Array.from(String(now));
        const lDeque = new DoublyLinkedList();
        const rDeque = new DoublyLinkedList();
        charArray.forEach(item => {
            lDeque.offerRear(item);
            rDeque.offerRear(item)
        });
        /* L */
        if (!lDeque.isEmpty())
            lDeque.offerRear(lDeque.pollFront().value);
        let lResult = '';
        while (!lDeque.isEmpty())
            lResult += lDeque.pollFront().value;
        lResult = parseInt(lResult);
        if (dist[lResult] === '')
        {
            queue.offer(lResult);
            dist[lResult] += dist[now] + 'L';
        }
        // /* R */
        if (!rDeque.isEmpty())
            rDeque.offerFront(rDeque.pollRear().value);
        let rResult = '';
        while (!rDeque.isEmpty())
            rResult += rDeque.pollFront().value;
        rResult = parseInt(rResult);
        if (dist[rResult] === '')
        {
            queue.offer(rResult);
            dist[rResult] += dist[now] + 'R';
        }
    }
    return ('');
}

class TwoWayNode {
    constructor(item) {
        this.value = item;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    offerFront(item) {
        const newNode = new TwoWayNode(item);
        if (!this.head)
        {
            this.head = newNode;
            this.tail = newNode;
        }
        else
        {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
        ++this.size;
    }

    offerRear(item) {
        const newNode = new TwoWayNode(item);
        if (!this.head)
        {
            this.head = newNode;
            this.tail = newNode;
        }
        else
        {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
        ++this.size;
    }

    pollFront() {
        const ret = this.head;
        this.head = this.head.next;
        if (!this.head)
            this.tail = null;
        else
            this.head.prev = null;
        --this.size;
        return (ret);
    }

    pollRear() {
        const ret = this.tail;
        this.tail = this.tail.prev;
        if (!this.tail)
            this.head = null;
        else
            this.tail.next = null;
        --this.size;
        return (ret);
    }
    isEmpty() {
        return (this.size === 0);
    }
}
```

# React Key

keyê°€ ì—†ìœ¼ë©´ Virtual DOMì„ ë¹„êµí•˜ëŠ” ê³¼ì •ì—ì„œ ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ë¹„êµí•˜ë©´ì„œ ë³€í™”ë¥¼ ê°ì§€í•œë‹¤.  

<strong>keyê°€ ìˆìœ¼ë©´ ì´ ê°’ì„ ì‚¬ìš©í•˜ì—¬ ì–´ë–¤ ë³€í™”ê°€ ì¼ì–´ë‚¬ëŠ”ì§€ ë”ìš± ë¹ ë¥´ê²Œ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤.</strong>  

###   

# <mark>Javascript Concat</mark>

```
const [names, setNames] = useState({
	{id: 1, text: 'ëˆˆì‚¬ëŒ'},
	{id: 2, text: 'ì–¼ìŒ'},
	{id: 3, text: 'ëˆˆ'},
	{id: 4, text: 'ë°”ëŒ'}
});

const [inputText, setInputText] = useState('');
const [nextId, setNextId] = useState(5);

const onClick = () => {
	const nextNames = names.concat({
		id: nextId;
		text: inputText;
	});
	setNextId(nextId + 1);
	setNames(nextNames);
	setInputText('');
}

...
```

ê·¸ëŸ¬ê³  ë³´ë‹ˆ, ê°ì²´ ë°°ì—´ì— ì •ì ìœ¼ë¡œë§Œ ë‹¤ë¤˜ì§€ ë™ì ìœ¼ë¡œ ì¶”ê°€ í•´ë³¸ì ì´ ì—†ì—ˆë‹¤.  

<strong>ë°˜ëŒ€ë¡œ ì œê±°ëŠ” filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•˜ì</strong>  

  

### <mark>ìƒíƒœ ì•ˆì—ì„œ ë°°ì—´ì„ ë³€í˜•í•  ë•ŒëŠ” ë°°ì—´ì— ì§ì ‘ ì ‘ê·¼í•˜ì—¬ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ concat, filterë“±ì˜ ë°°ì—´ ë‚´ì¥ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ë°°ì—´ì„ ë§Œë“  í›„ ì´ë¥¼ ìƒˆë¡œìš´ ìƒíƒœë¡œ ì„¤ì •í•´ ì£¼ì–´ì•¼ í•œë‹¤ëŠ” ì ì„ ëª…ì‹¬í•˜ì</mark>


---
layout: post
title: "TIL Operating System 강의"
author: "hyunwlee"
---

## <span style="background-color:#E81E25; color:white">42seoul(philosophors)</span>

#### <span style="background-color:#FE7773; color:white">학습 목표</span>

- 용어 정리

  - [x] mutex vs. semaphore

  - [x] mandatory_External functs. [philosopher with threads and mutex]
    - usleep
    - gettimeofday
    - pthread_create
    - pthread_detach
    - pthread_join
    - pthread_mutex_init
    - pthread_mutex_destroy
    - pthread_mutex_lock
    - pthread_mutex_unlock
  - [x] bonus_External functs. [philosopher with process and semaphore]
    - fork
    - kill
    - usleep
    - gettimeofday
    - pthread_create
    - pthread_detach
    - pthread_join
    - waitpid
    - sem_open
    - sem_close
    - sem_post
    - sem_wait
    - sem_unlink

---

#### <span style="background-color:#FFC2C3; color:white"><strong>Mutex(part. mandatory) vs. semaphore(part. bonus)</strong></span>

용어정리 이전에 앞서 philosophers는 mutex(mandatory)와 semaphore(bonus)를 이용한 것으로 나뉜다. 

전에 philosophers를 평가하는데 의문이 있었다.

피평가자분의 <strong>mutex</strong>를 알고계신 내용에 내가 알고있는 <strong>mutex</strong>가 개념적으로 부족하여 평가동안 혼동에 시달렸기 때문에 시작전 mutex와 semaphore의 정의를 정확히 짚고 가야겠단 생각이 들었다.

- 평가봐주기 전: Mutex는 Semaphore 타입 중{1. Counting semaphore, 2. Binary semaphore} 2. Binary semaphore와 같다. 또, <u>Mut</u>ual + <u>Ex</u>clusion에서 가져온 Mutex 줄임말으로서 <strong>상호배재 lock / unlock에서 사용된다.</strong>
- 평가봐주기 후: 
  - <strong>Mutex</strong>: 공유된 자원의 데이터를 <strong><u>여러 쓰레드가 접근</u></strong>하는 것을 막는 것
  - <strong>Semaphore</strong>: 공유된 자원의 데이터를 <strong><u>여러 프로세스가 접근</u></strong>하는 것을 막는 것
  - Mutex의 동작 원리
    - 뮤텍스는 세마포어와 마찬가지로 병행처리를 위한 동기화 기법중 하나
    - 이진 세마포어와 같이 초기값을 1과 0으로 가집니다.
    - 임계영역에 들어갈 때(lock)을 걸어 다른 프로세스(혹은 쓰레드)가 접근하지 못하도록 하고, 임계영역에서 나와 해당 락을 해제(unlock)합니다.
  - Semaphore의 동작 원리 <span style="color:gray">_"제대로 알려면 Semaphore변수, semWait연산, semSignal연산에 대해 먼저 알아야 한다."_</span>
    - 세마포어는 정수 값을 가지는 변수로 볼 수 있습니다. 그 정수 값은 접근할 수 있는 최대 허용치 만큼 동시에 사용자 접근을 할 수 있게 합니다. (counting semaphore)
- 결론
  - 세마포어는 공유 자원에 세마포어의 변수만큼 프로세스(또는 스레드)가 접근할 수 있다. 반면에 뮤텍스는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있다. 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다. 하지만 뮤텍스는 lock을 획득한 프로세스가 반드시 그 락을 해제해야 한다.



<span style="color:gray">_"Philosophers상에서 Mutex와 Semapore"_</span>

- <span style="color:gray">_"shared data에 접근하는 단위가 중요한 것 같다."_</span>
- <span style="color:gray">_"내가알던 Monitor내용은 Semaphore를 뜻하는 것 같았고, 내가 알던 Mutex가 내가 알던 Semaphore가 된 기분이다."_</span>

<span style="color:gray">_"이론상으로 배운것일 뿐이여서 코딩을 해나가면서 정리를 이어가겠다."_</span>

---

#### <span style="background-color:#FFC2C3; color:white"><strong>동기화 문제</strong></span>

#### Process Synchronization Problem

공유 데이터(shared data)의 동시접근(concurrent access)은 데이터의 불일치 문제를 발생시킬 수 있다.

일관성 유지를 위해서는 협력 프로세스간의 <strong>실행순서</strong>를 정해주는 매커니즘 필요

<strong>Race Condition</strong>

- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- race condition을 막기 위해서는 <strong>동시 접근(concurrent process)는 동기화(synchronize)되어야 한다.</strong>

<strong>Critical-section Problem</strong>

- n개의 프로세스들이 공유 데이터를 동시에 사용하기를 원하는 경우
- 각 프로세스의 <strong>code segment</strong>에는 공유 데이터를 접근하는 코드인 <strong>critical section</strong>이 존재
- 하나의 프로세스가 <strong>critical section</strong>에 있을 때 다른 모든 프로세스는 <strong>critical section</strong>에 들어갈 수 없다.
- 필요 충족 조건: <strong>Mutual Exclusion, Progress, Bounded Waiting</strong>

<strong>Synchronization Software vs. Hardware vs. Semaphore vs. Monitor</strong>

- Software

  - 고급언어의 문장 하나가 여러 CPU Instruction으로 구성된다. 

  - 문장 중간 과정하에 CPU를 빼앗길 수 있으므로 복잡한 코드가 만들어진다.

  - <script src="https://gist.github.com/hyunwlee-dev/659265f418eea8c090b38a8e54bbdb97.js"></script>

- Hardware

  - atomic(하나의 Instruction만) 실행되기 때문에 간단한 코드가 만들어진다.

  - Test & modify

  - <script src="https://gist.github.com/hyunwlee-dev/a5230f9d4c2a22d6c3e6b9bcf2d3af41.js"></script>

- Semaphores

  - <strong>Variable</strong>: 자원의 갯수, <strong>Operations</strong>: P(S), V(S)

  - <script src="https://gist.github.com/hyunwlee-dev/fa151c12fed4071c20591d9ec38160fe.js"></script>

  - <strong>busy wait</strong>의 문제성

    - <strong>Block / Wakeup Implementation</strong>: Semaphore 구조체에 Queue를 만들어 CPU를 차지할 수 없는 프로세스들은 이 큐에 suspend시킨다.

    - <script src="https://gist.github.com/hyunwlee-dev/2e121e9e9143e1ffd22854afbb50232a.js"></script>

    - <script src="https://gist.github.com/hyunwlee-dev/f230d6324155bc7a559e79432abcf14d.js"></script>

  - <strong>Deadlcok과 Starvation</strong>

---

#### <span style="background-color:#FFC2C3; color:white"><strong>Philosophers 문제 이해</strong></span>

<img src="https://github.com/hyunwlee-dev/TIL/blob/cc5d862123c997d19db946fc9cce37f8a4be0331/images/til211004/spagetti.png?raw=true" style="zoom:50%;"/>

<script src="https://gist.github.com/hyunwlee-dev/753799c9364017a1c16042daf219b4e5.js"></script>

<strong>문제점</strong>

<strong>Deadlock</strong>: 모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우

<strong>해결책</strong>

1. (n - 1)명의 철학자만이 테이블에 동시에 앉을 수 있도록한다.
2. 젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.
3. 비대칭
   - 짝수 철학자는 왼쪽 젓가락을 집도록
   - 홀수 철학자는 오른쪽 젓가락을 집도록

---

#### <span style="background-color:#FFC2C3; color:white"><strong>사용함수 정리</strong></span>

<img src="https://github.com/hyunwlee-dev/TIL/blob/4664167a687a974579de602b2348856051111ce1/images/til211018/philo1.png?raw=true" style="zoom:30%;"/>

#### 1. usleep

```c
#include <unistd.h>

int usleep(useconds_t usec) 
```

마이크로초 간격 동안 <strong>suspend</strong>한다.  usleep(1)하면 1/1,000,000초를 나타냄. sleep()보다 정밀한 사용을 위한 함수. <span style="color:gray">_"보류 시간은 인수 값이 슬립 해상도의 정수 배수로 반올림되거나 시스템에 의한 다른 활동 스케줄링으로 인해 요청된 시간보다 길 수 있습니다."_</span>



여기서 suspend는 무엇일까? <span style="color:gray">_"프로세스를 Blocked? Suspended?"_</span>

_Blocked vs. Suspended_

Running, Ready, Blocked 모두 CPU 관점에서의 상태 분류일 뿐 실제로 프로세스의 작업이 수행이 되고 있는 상태 (CPU에서 프로세스 수행중(Running), I/O에서 프로세스 수행중(Blocked)), 반면 Suspended 는 프로세스 수행 자체가 외부에 의해 정지된 상태

- Blocked: 자신이 요청한 event가 만족되면 Ready
- Suspended: 외부에서 resume해 주어야 Active, 프로세스는 통째로 디스크에 swap out된다.



#### 결론: sleep은 sleep이다.

<strong>sleeping vs. blocked vs. suspended</strong>

sleeping

- "Sleeping" -- 말 그대로 sleep()

blocked

- "Blocked" -- 셋중 가장 일반적임. 주로 프로세스/스레드가 무언가를 기다리고 있다. 가끔은 I/O 명령을 기다린다.

suspended

- "Suspended" -- 때때로 일반적인 방법으로 사용됨. 즉, thread는 무언가를 기다리고 있다는 의미입니다. 다른 경우, 다른 스레드 또는 프로세스가 명시적으로 중단되었음을 의미합니다. (ex. 디버깅 목적으로) 그리고 프로세스/스레드도 명시적으로 재개될 때까지 다시 실행할 수 없습니다.

<center>[usleep 사용 예시]</center>

<script src="https://gist.github.com/hyunwlee-dev/7bfcfbe0233103bbdeb6b8ffd85d1ade.js"></script>



#### <strong>blocked 상태가 되는 경우</strong>

<img src="https://github.com/hyunwlee-dev/TIL/blob/599be4320bf8e0949b74c9d45adf9b1d7e8d4158/images/til211006/os27.png?raw=true" style="zoom:30%;"/>

1. 사용자 프로그램이 I/O작업이 필요한 경우 interrupt line of CPU에 <strong>system call</strong> of Trap을 한다. (CPU에게 내가 할 수 없는일이라 Kernel이 동작하겠금 알리는 것)

2. Block & Wakeup (=sleep lock)

   - lock에 걸리면 while(lock);을 CPU에게 계속 수행키는 것 (Busy Waiting)을 회피하기 위하여

   - 어떤 프로세스가 공유 데이터를 접근하고 있으면 다른 프로세스가 접근 못하도록 <strong>blocked</strong>상태로 빠져들게 한다.
   - 공유데이터에 접근하고 있던 프로세스가 내 놓으면 그때 Ready Queue에 들어와서 CPU를 얻을 수 있다.



#### suspended

- 외부적인 이유로 프로세스의 수행이 정지된 상태
- 프로세스는 통째로 디스크에 swap out된다.
- 메모리를 빼앗긴 상태를 표현
- ex) ctrl + z, 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)



#### *suspended vs. blocked (preempted vs. nonpreempted)*

- Blocked: 자신이 요청한 event가 만족되면 Ready
- Suspended: 외부에서 resume해 주어야 Active



preemptive, nonpreemptive, blocked, suspended, sleep

---

#### 2. gettimeofday

```c
#include <sys/time.h>

int gettimeofday(struct timeval *tv, struct timezone *tz);
```

특정구간의 수행시간 차이를 계산하기 위해 마이크로 단위의 시간함수 gettimeofday를 지원합니다.

<script src="https://gist.github.com/hyunwlee-dev/cc6597e38ec28109392a6cce5e286e5c.js"></script>

<script src="https://gist.github.com/hyunwlee-dev/9ab6e7b48b4bd61230722263b1935406.js"></script>

gettimeofday(struct timeval *tv, NULL) 사용시

<strong>tv_sec</strong>: 현재 시간에 관한 초

<strong>tv_usec</strong>: 현재 시간에 관한 마이크로 초



<strong>Return</strong>

- 0: <strong>gettimeofday()</strong> was successful.

- -1: <strong>gettimeofday()</strong> was not successful. The errno variable is set to indicate the error.

---

- pthread_create
- pthread_join
- pthread_detach

---

#### 3. <strong>pthread_create</strong>

```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```

<strong> 쓰레드를 생성한다.</strong>

1. <strong>thread</strong>: 성공적으로 함수가 호출되면 이곳에 thread ID가 저장된다. 이 인자로 넘어온 값을 통해서 pthread_join과 같은 함수를 사용할 수 있다.
2. <strong>attr</strong>: thread 특성을 정의한다.. 기본적으로 NULL을 지정함. 만약 thread의 속성을 지정하려고 한다면 pthread_attr_init등의 함수로 초기화해야한다.
3. <strong>start_routine</strong>: 사용할 함수 포인터를 매개변수로 받는다.
4. <strong>arg</strong>: start_routine에 전달될 인자를 말한다. start_routine에서 이 인자를 변환하여 사용한다.

<script src="https://gist.github.com/hyunwlee-dev/e00e893b3d45350327cf0beefc48f913.js"></script>

<center><strong>[pthread_create 결과]</strong></center>

```
tid:104aae00
main:0
        tid:98a8000
        new thread:0
main:1
        new thread:1
main:2
        new thread:2
main:3
        new thread:3
main:4
        new thread:4
        new thread:5
```

pthread_create를 통해서 thread_routine을 실행시키고 있다.

메인 스레드가 끝나면 thread도 동시에 끝나게 된다.



프로세스에서는 wait가 필요

<span style="color:gray">*“사람의 세계로 보면 잔인하다. 자식이 사치를 한다고 죽이고, 자식이 이제 필요없어서 죽이고, 부모가 죽기직전 죽인다.”*</span>



<span style="color:gray">_"pthread_t 구조체는 현재 쓰레드의 식별자 정보를 담고 있습니다.  코드 내에서 pthread_self() 를 실행하면 현재 쓰레드의 식별자를 확인할수 있습니다"_</span>

---

#### 4. pthread_join

```c
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
```

<strong>thread를 끝날때까지 기다려준다. 만약 thread가 이미 종료되었다면 즉시 리턴한다.</strong>

1. <strong>thread</strong>: join하려고 하는 thread를 명시해준다.
2. <strong>retval</strong>: pthread_create에서 start_routine이 반환하는 반환값을 여기에 저장한다.



만약 성공적으로 호출이 되었다면 0을 반환한다. 실패시 에러 넘버를 반환한다. 실패시에는 좀비 스레드가 되고 이 좀비 스레드는 자원을 소모하게 되어 더 이상 스레드를 생성할 수 없게 된다.

<script src="https://gist.github.com/hyunwlee-dev/4e7416c578ed28765e12f3de0ab6dcf9.js"></script>

여기서는 thread_routine이 반환하는 값이 없으므로 두번째 인자는 <strong>NULL</strong>이다.

<center><strong>[pthread_join 결과]</strong></center>

```
tid:ca97e00
main:0
        tid:364e000
        new thread:0
main:1
        new thread:1
main:2
        new thread:2
        new thread:3
main:3
        new thread:4
main:4
        new thread:5
        new thread:6
        new thread:7
        new thread:8
        new thread:9
```

---

#### 5. pthread_detach

```c
#include <pthread.h>

int pthread_detach(pthread_t thread);
```



때에 따라서는 스레드가 독립적으로 동작하길 원할 수 도 있다. 단지 pthread_create후에 pthread_join으로 기다리지 않고 나는 기다려주지 않으니 끝나면 알아서 끝내도록 주문하는 방식이다.



독립적인 동작을 하는 대신에 thread가 끝이나면 반드시 자원을 반환시켜야 한다. pthread_create만으로 스레드를 생성하면 루틴이 끝나서도 자원이 반환되지 않는다. 이 문제점을 해결해주는 함수가 바로 pthread_detach이다.

---

- pthread_mutex_init
- pthread_mutex_destroy
- pthread_mutex_lock
- pthread_mutex_unlock

---

### Critical Section

<script src="https://gist.github.com/hyunwlee-dev/fdb0790bd9ad2ab99ebe71f02ef8988b.js"></script>

```
thread1 cnt: 0
thread2 cnt: 0
thread1 cnt: 1
thread2 cnt: 2
thread1 cnt: 4
thread2 cnt: 5
thread1 cnt: 6
thread2 cnt: 7
thread1 cnt: 7
thread1 cnt: 9
thread2 cnt: 10
thread1 cnt: 10
thread2 cnt: 12
thread1 cnt: 12
thread2 cnt: 13
thread1 cnt: 15
thread2 cnt: 15
thread1 cnt: 17
thread2 cnt: 17
thread2 cnt: 19
```

뮤텍스를 이용한 critical section에서 synchronization이 필요하다.

이에 필요한 함수

- pthread_mutex_init
- pthread_mutex_lock
- pthread_mutex_unlock
- pthread_mutex_destroy

---

#### 6. pthread_mutex_init

<strong>mutex를 초기화하는데에는 두 가지 방법이 존재</strong>

1. <u>정적</u>으로 할당된 mutex를 초기화
   - <strong>PTHREAD_MUTEX_INITIALIZER</strong> 상수를 이용해서 초기화
2. <u>동적</u>으로 할당된 mutex를 초기화
   - <strong>pthread_mutex_init</strong> 함수를 사용

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
```

1. <strong>mutex</strong>: mutex 변수
2. <strong>attr</strong>: mutex의 속성, default로 <strong>NULL</strong>을 사용

---

#### 7. pthread_mutex_lock & pthread_mutex_unlock

이 두 함수는 mutex를 이용하여 임계 구역을 진입할때 그 코드 구역을 lock하고 다시 임계 구역이 끝날때 다시 풀어 다음 thread가 진입할 수 있도록 한다.

```c
#include <pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

---

#### 8. phtread_mutex_destroy

만약 mutex를 동적으로 생성(pthread_mutex_init을 이용하여 초기화)했다면 phtread_mutex_destroy가 필요하다.

```c
#include <pthread.h>

int	pthread_mutex_destroy(pthread_mutex_t *mutex);
```

---

<script src="https://gist.github.com/hyunwlee-dev/aed2ab6bc5580acea2e655b6ebb7c561.js"></script>

```
thread1 cnt: 0
thread1 cnt: 1
thread1 cnt: 2
thread1 cnt: 3
thread1 cnt: 4
thread1 cnt: 5
thread1 cnt: 6
thread1 cnt: 7
thread1 cnt: 8
thread1 cnt: 9
thread2 cnt: 0
thread2 cnt: 1
thread2 cnt: 2
thread2 cnt: 3
thread2 cnt: 4
thread2 cnt: 5
thread2 cnt: 6
thread2 cnt: 7
thread2 cnt: 8
thread2 cnt: 9
```

---


---
layout: post
title: "BOJ DynamicProgramming 알고리즘, 42SEOUL(Minishell)"
author: "hyunwlee"
---

## <span style="background-color:#1D6A96; color:white">BOJ (Dynamic Programming)</span>

<span style="background-color:#85B8CB; color:white"><strong>금일 푼 문제</strong></span>

1. boj, [쉬운 계단 수](https://www.acmicpc.net/problem/10844)

### <span style="background-color:#85B8CB; color:white"><strong>오늘의 요약</strong></span>

- 쉬운 계단 수
  - 점화식 생각해 내는 것도, 사용해야할 추상자료형 마저도 생각해내기가 어려웠다...

---

<span style="background-color:#85B8CB; color:white"><strong>풀이</strong></span>

#### <u>0은 1로부터 온다.</u> 

#### 1은 0과 2로 부터 온다. 2는 1과 3으로 부터 온다... 8은 7과 9로 부터 온다. 

#### <u>9는 8로 부터온다.</u>

```
// pseudo code

/* init */
memo[1][0]  ~ memo[1][9]= 1;

/* recurse */
if (i == 0)
	return (D[N][i] = D[N - 1][1]);
if (i == 9)
	return (D[N][i] = D[N - 1][8]);
return (D[N][i] = D[N - 1][i - 1] + D[N - 1][i + 1]);
```



   <span style="background-color:#1D6A96;color:white"><u>0 1 2 3 4 5 6 7 8 9</u></span>

#### input: 2 -> topDown(2, 1) + topDown(2, 2) + topDown(2, 3) + .. + topDown(2, 9)

**1** 1 1 1 1 1 1 1 1 1 1
**2** 0 2 2 2 2 2 2 2 2 1



#### input: 3

10 12 / 21 23 / 2 / 2 / .. / 2 / 98
**1** 1 1 1 1 1 1 1 1 1 1 
**2** 1 2 2 2 2 2 2 2 2 1 
**3** 0 3 4 4 4 4 4 4 3 2 



#### input: 4

**1** 1 1 1 1 1 1 1 1 1 1 
**2** 1 2 2 2 2 2 2 2 2 1 
**3** 2 3 4 4 4 4 4 4 3 2 
**4** 3 6 7 8 8 8 8 7 6 3 
**5** 6 10 14 15 16 16 15 14 10 6 
**6** 10 20 25 30 31 31 30 25 20 10 
**7** 20 35 50 56 61 61 56 50 35 20 
**8** 35 <span style="background-color:lightpink">70</span> 91 111 117 117 111 91 70 35 
**9** <span style="background-color:lightpink">70</span> 126 181 <span style="background-color:lightgreen">208</span> 228 <span style="background-color:lightgreen">228</span> 208 181 <span style="background-color:lightblue">126</span> 70
**10** 0 251 334 409 <span style="background-color:green;color:white">436</span> 436 409 334 251 <span style="background-color:lightblue">126</span>



0으로 시작하는 계단은 없다. 따라서 n일 때 0은 필요없다. 

하지만 n - 1일때 0의 값은 필요하다. 

<script src="https://gist.github.com/hyunwlee-dev/9b6afcf8e8668eaf5946b838bdd9d0a0.js"></script>

---

## <span style="background-color:#E81E25; color:white">42seoul(Minishell)</span>

### <span style="background-color:#FFC2C3"><strong><u>1. Signal</u></strong></span>

- <strong>시그널이란?</strong>
  - 프로세스에게 전달되는 소프트웨어 인터럽트(Interrupt) 신호
  - 소프트웨어 인터럽트를 수신한 프로세스는 신호의 종류에 따라 등록한 핸들러(Handler)를 수행하거나, 무시 또는 운영체제 제어에 의한 프로세스 종료 등이 수행됨
  - 관련 API들: kill, signal, abort, alarm, raise, sigsend등
- <strong>시그널 종류</strong>
  - "man signal"
- <strong>시그널 종류</strong>
  - SIGINT(2)
    - 키보드로 부터 오는 인터럽트 시그널로 실행을 중지
    - [ctrl] + [c] 입력 시에 보내지는 시그널.
  - SIGQUIT(3)
    -  Quit from keyboard.
    - [ctrl] + [\\] 입력 시에 보내지는 시그널.
    - <strong>SIG_IGN</strong>
  - SIGCHLD(20): 자식 프로세스가 stop되거나 종료되었을 때 부모에게 전달되는 신호입니다. (멀티 프로세스 코딩에서)

<center><strong>Signal Handling 예제 코드</strong></center>

<script src="https://gist.github.com/hyunwlee-dev/242a968485d2a190669477ab44803fe7.js"></script>

근데 ctrl + D는 signal handling을 안하나?



---

### <span style="background-color:#FFC2C3"><strong><u>2.canonical vs. non-canonical</u></strong></span>

1. non-canonical과 Unix Ctrl + D의 관계

2. non-canonical과 history의 관계

- slack [keyword:논캐노니컬]
  - 히스토리를 구현하기 위해 논캐노니컬 모드에서 입력을 받아오는 로직을 만들었습니다. (..?)



<strong>canonical</strong>

- 문자열을 받아온다.

<strong>non-canonical</strong>

- 문자 하나를 하나씩 받아와 저장한다. -> 엔터를 누르기 전 입력중인 문자도 저장할 수 있다 카더라..

#### Unix Ctrl + D?

EOF를 나타냄.

[Unix \[ctrl + D]](https://m.blog.naver.com/lifehelp/80104786507)




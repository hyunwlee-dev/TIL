---
layout: post
title: "BOJ DynamicProgramming 알고리즘, 42SEOUL(Minishell)"
author: "hyunwlee"
---

## <span style="background-color:#1D6A96; color:white">BOJ (Dynamic Programming)</span>

<span style="background-color:#85B8CB; color:white"><strong>금일 푼 문제</strong></span>

1. boj, [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

### <span style="background-color:#85B8CB; color:white"><strong>오늘의 요약</strong></span>

- Dynamic Programming
  - 점화식
  - 큰 문제를 작은 문제를 사용해 해결하는 방법
  - 메모이제이션
  - 과거에 구한 해를 활용하는 방법
  - 즉, <u>재귀적으로 생각하기 + 불필요한 계산 줄이기</u>

---

<span style="background-color:#85B8CB; color:white"><strong>풀이</strong></span>

### 점화식

```markdown
for (int i = N - 1; i >= 0; i--)
	if (arr[i] < arr[N])
		memo[N] = max(memo[N], topDown(i) + 1);
```



먼저 N번째 값에 대해 이전에 탐색한 결과물이 있는지를 검사한다.  

탐색했다면 그 memo값을 반환해버리고 안했다면 그 memo[N] 을 1로 초기화 해준다. 이유는 모든 부분수열의 길이는 <strong><u>최소한 1 이상</u></strong>이기 때문이다.  

그 다음은 예시를 보며 이해하도록 하자.  



#### 예시

(대신 arr[i] < arr[n] 이여야 한다.)

<span style="background-color:lightgray">ex) <strong>1</strong> < 23 < 8 < <strong>4</strong> < <strong>5</strong></span>

<strong>memo[4]</strong> = max(memo[4], <strong>topDown[3]</strong> = max(memo[3] (=1), <strong>topDown[0]</strong> = 1) + 1) + 1)  

topDown[3] = max(memo[])

<script src="https://gist.github.com/hyunwlee-dev/9eb67c4e664b05bd06fb233a90eb4236.js"></script>

---

## <span style="background-color:#E81E25; color:white">42seoul(Minishell)</span>

## <span style="background-color:#FFC2C3"><strong><u>Parsing</u></strong></span>

## 들어오는 문자열 (char *input)을 Parsing

---

### Abstract Data Type

1. <span style="background-color:#FFC2C3"><strong><u>t_list *cmd</u></strong></span>

```
typedef struct s_list // libft.h에 있는 구조체를 변형할 것인가? or 새로 구조체를 만들것인가?
{
	char *content;
	struct s_list *next;
}	t_list
```

2. <span style="background-color:#FFC2C3"><strong>t_address_space</strong></span>

```
int pid;
...
```



### Data Structure

...

---

### 들어오는 문자열에서 `'|'`갯수 만큼 multiprocessing

